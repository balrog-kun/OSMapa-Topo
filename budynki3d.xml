<Style name="komzpa-buildings">
 <!-- Edges -->
 <Rule>
  <Filter>([visible] = 'yes-v' and [diff] &gt; 0.4 and [diff] &lt;= 0.7) or [visible] = 'yes-h' or [visible] = 'border-yes-v'</Filter>
  &maxscale_zoom17;
  <LineSymbolizer
   stroke="#444444"
   stroke-width=".3"
   stroke-linejoin="round"
  />
 </Rule>
 <Rule>
  <Filter>[visible] = 'yes-v' and [diff] &gt; 0.7</Filter>
  &maxscale_zoom17;
  <LineSymbolizer
   stroke="#444444"
   stroke-width=".5"
   stroke-linejoin="round"
  />
 </Rule>
 <Rule>
  <Filter>[visible] = 'yes-v' and [diff] &gt; 0.3 and [diff] &lt;= 0.45</Filter>
  &maxscale_zoom17;
  <LineSymbolizer
   stroke="#444444"
   stroke-width=".2"
   stroke-linejoin="round"
  />
 </Rule>
 <Rule>
  <Filter>[visible] = 'yes-v' and [diff] &gt; 0.15 and [diff] &lt;= 0.3</Filter>
  &maxscale_zoom17;
  <LineSymbolizer
   stroke="#444444"
   stroke-width=".1"
   stroke-linejoin="round"
  />
 </Rule>
 <Rule>
  <Filter>[visible] = 'no-h'</Filter>
  &maxscale_zoom17;
  <LineSymbolizer
   stroke="#444444"
   stroke-width=".2"
   stroke-linejoin="round"
  />
 </Rule>
 <Rule>
  <Filter>([visible] = 'no-v' and [diff] &gt; 0.3) or [visible] = 'border-no-v' or [visible] = 'no-h-d'</Filter>
  &maxscale_zoom17;
  <LineSymbolizer
   stroke="#444444"
   stroke-width=".3"
   stroke-linejoin="round"
   stroke-dasharray="3,3"
  />
 </Rule>

 <!-- Planes -->
 <Rule>
  &maxscale_zoom17;
  <Filter>[visible] = 'yes'</Filter>
  <PolygonSymbolizer
   fill="silver"
   fill-opacity="0.3"
  />
 </Rule>
 <Rule>
  &maxscale_zoom17;
  <Filter>[hv] = 1 and [visible] = 'yes' and [azim] &gt;= 0.0 and [azim] &lt; 18.0</Filter>
  <PolygonSymbolizer
   fill="silver"
   fill-opacity="0.35"
  />
 </Rule>
 <Rule>
  &maxscale_zoom17;
  <Filter>[hv] = 1 and [visible] = 'yes' and [azim] &gt;= 18.0 and [azim] &lt; 36.0</Filter>
  <PolygonSymbolizer
   fill="silver"
   fill-opacity="0.345105651629"
  />
 </Rule>
 <Rule>
  &maxscale_zoom17;
  <Filter>[hv] = 1 and [visible] = 'yes' and [azim] &gt;= 36.0 and [azim] &lt; 54.0</Filter>
  <PolygonSymbolizer
   fill="silver"
   fill-opacity="0.33090169943"
  />
 </Rule>
 <Rule>
  &maxscale_zoom17;
  <Filter>[hv] = 1 and [visible] = 'yes' and [azim] &gt;= 54.0 and [azim] &lt; 72.0</Filter>
  <PolygonSymbolizer
   fill="silver"
   fill-opacity="0.30877852523"
  />
 </Rule>
 <Rule>
  &maxscale_zoom17;
  <Filter>[hv] = 1 and [visible] = 'yes' and [azim] &gt;= 72.0 and [azim] &lt; 90.0</Filter>
  <PolygonSymbolizer
   fill="silver"
   fill-opacity="0.2809016994"
  />
 </Rule>
 <Rule>
  &maxscale_zoom17;
  <Filter>[hv] = 1 and [visible] = 'yes' and [azim] &gt;= 90.0 and [azim] &lt; 108.0</Filter>
  <PolygonSymbolizer
   fill="silver"
   fill-opacity="0.25"
  />
 </Rule>
 <Rule>
  &maxscale_zoom17;
  <Filter>[hv] = 1 and [visible] = 'yes' and [azim] &gt;= 108.0 and [azim] &lt; 126.0</Filter>
  <PolygonSymbolizer
   fill="silver"
   fill-opacity="0.21909830056"
  />
 </Rule>
 <Rule>
  &maxscale_zoom17;
  <Filter>[hv] = 1 and [visible] = 'yes' and [azim] &gt;= 126.0 and [azim] &lt; 144.0</Filter>
  <PolygonSymbolizer
   fill="silver"
   fill-opacity="0.191221474771"
  />
 </Rule>
 <Rule>
  &maxscale_zoom17;
  <Filter>[hv] = 1 and [visible] = 'yes' and [azim] &gt;= 144.0 and [azim] &lt; 162.0</Filter>
  <PolygonSymbolizer
   fill="silver"
   fill-opacity="0.169098300562"
  />
 </Rule>
 <Rule>
  &maxscale_zoom17;
  <Filter>[hv] = 1 and [visible] = 'yes' and [azim] &gt;= 162.0 and [azim] &lt; 180.0</Filter>
  <PolygonSymbolizer
   fill="silver"
   fill-opacity="0.15489434837"
  />
 </Rule>

 <!-- Flat rooves -->
 <Rule>
  &maxscale_zoom17;
  <Filter>[hv] = 2 and [visible] = 'yes-h'</Filter>
  <PolygonSymbolizer
   fill="silver"
   fill-opacity=".4"
  />
 </Rule>

</Style>

<Layer>
 <StyleName>komzpa-buildings</StyleName>
 <Datasource>
  &datasource-settings;
  <Parameter name="table">
(
(
WITH

buildingparts AS
  (SELECT ST_Buffer(way, 0) AS way, "building:levels", height, "roof:height",
     "building:min_level", min_height, "roof:shape"
   FROM planet_osm_polygon
   WHERE "building:part" IS NOT NULL AND
     (height IS NOT NULL OR "building:levels" IS NOT NULL) AND
     way &amp;&amp; ST_Expand(!bbox!, 500)),

buildingswhole AS
  (SELECT ST_Buffer(way, 0) AS way, "building:levels", height, "roof:height",
     "building:min_level", "min_height", "roof:shape"
   FROM planet_osm_polygon AS a
   WHERE (building IS NOT NULL OR "man_made" IN ('chimney', 'tower')) AND
     (building IS NOT NULL OR height IS NOT NULL OR
      "building:levels" IS NOT NULL) AND
     way &amp;&amp; ST_Expand(!bbox!, 500)),

rawbuildings AS (
  SELECT * FROM buildingparts

  UNION

  SELECT *
  FROM buildingswhole AS a
  WHERE
    NOT EXISTS (
      SELECT 1
      FROM buildingparts AS b
      WHERE ST_Contains(a.way, b.way)) OR
        -- Also should really just check if a and b also intersect vertically,
        -- but for that we'd need the string to float conversion and NULL checks
        -- which are done later..
        -- Instead, if the building contains any building:part's then we check
        -- if its interior also intersects with any other buildings.  If that
        -- is true, then, probably, we need to render both the buildings and
        -- the building:part's.  There are several ways in which this logic
        -- could fail though.  We probably need to use functions here.
    EXISTS (
      SELECT 1
      FROM buildingswhole AS b
      WHERE ST_Contains(a.way, b.way) OR ST_Contains(b.way, a.way))

  UNION

  SELECT ST_Buffer(way, 2.5) AS way, "building:levels", height, "roof:height",
    "building:min_level", min_height, "roof:shape"
  FROM planet_osm_point
  WHERE (building IS NOT NULL OR "man_made" IN ('chimney', 'tower')) and
    (height IS NOT NULL OR "building:levels" IS NOT NULL) AND
    way &amp;&amp; ST_Expand(!bbox!, 500)

  UNION

  SELECT ST_Buffer(way, 0.1, 1) AS way, "building:levels",
     CASE WHEN height IS NOT NULL THEN height ELSE '1.0' END AS height,
     "roof:height", "building:min_level", min_height, "roof:shape"
  FROM planet_osm_line
  WHERE (building IS NOT NULL OR "man_made" IN ('chimney', 'tower') OR
     barrier IN ('fence','wall')) AND
    way &amp;&amp; ST_Expand(!bbox!, 500)

  UNION

  SELECT ST_Buffer(ST_Boundary(way), 0.1, 1) AS way, "building:levels",
    CASE WHEN "height" IS NOT NULL THEN height ELSE '1.0' END AS height,
    '0' AS "roof:height", "building:min_level", "min_height",
    NULL AS "roof:shape"
  FROM planet_osm_polygon
  WHERE barrier IN ('fence','wall') AND way &amp;&amp; ST_Expand(!bbox!, 500)
), -- end of "rawbuildings AS"

rawbuildingswithroof AS
      (SELECT *,
           CASE WHEN z."height" ~ E'^(-)?[[:digit:]]+([.][[:digit:]]+)?$'
               THEN CAST (z."height" AS FLOAT) ELSE
               CASE WHEN z."building:levels" ~ E'^(-)?[[:digit:]]+([.][[:digit:]]+)?$'
                    THEN CAST (z."building:levels" AS FLOAT) * 3 ELSE 6 END END AS hei,
           CASE WHEN z."min_height" ~ E'^(-)?[[:digit:]]+([.][[:digit:]]+)?$'
               THEN CAST (z."min_height" AS FLOAT) ELSE
               CASE WHEN z."building:min_level" ~ E'^(-)?[[:digit:]]+([.][[:digit:]]+)?$'
                   THEN CAST (z."building:min_level" AS FLOAT) * 3 ELSE 0 END END AS minhei,
           CASE WHEN z."roof:height" ~ E'^(-)?[[:digit:]]+([.][[:digit:]]+)?$'
               THEN CAST (z."roof:height" AS FLOAT) ELSE 0 END AS rhei,
           "roof:shape" AS rshape
       FROM rawbuildings AS z
      ), -- END OF "rawbuildingswithroof AS"

buildings AS
      (SELECT * FROM
           (SELECT ST_ForceRHR(ST_SimplifyPreserveTopology(way, .4)) AS way,
                GREATEST(z.hei - z.rhei, z.minhei) * &tilt; AS hei,
                LEAST(z.hei - z.rhei, z.minhei) * &tilt; AS minhei,
                LEAST(z.hei, z.rhei) * &tilt; AS rhei,
                rshape
            FROM rawbuildingswithroof AS z
           ) zz -- WHERE GeometryType(way) = 'POLYGON' for some reason doing this here is slower than repeating it &gt; 1 times belowe
      ), -- END OF "buildings AS"

byhei AS
  (SELECT hei, ST_Buffer(ST_Collect(way), 0) AS way
   FROM buildings WHERE rshape IS NULL OR rshape NOT IN (
     'skillion', '1.0',
     'pyramidal', '2.5')
   GROUP BY hei),

byminhei AS
  (SELECT minhei, ST_Buffer(ST_Collect(way), 0) AS way
   FROM buildings GROUP BY minhei),

joined AS
   (SELECT CASE WHEN n.hei IS NOT NULL THEN n.hei ELSE o.minhei END AS hei,
        --n.way AS maxway, o.way AS minway,
        CASE WHEN n.way IS NOT NULL THEN CASE WHEN o.way IS NOT NULL THEN
            ST_Difference(n.way, o.way) ELSE n.way END ELSE NULL END AS maxmin,
        CASE WHEN o.way IS NOT NULL THEN CASE WHEN n.way IS NOT NULL THEN
            ST_Difference(o.way, n.way) ELSE o.way END ELSE NULL END AS minmax
    FROM byhei AS n FULL OUTER JOIN byminhei AS o ON n.hei = o.minhei)

-------------- End of WITH definitions, the query starts here ---------------

                     -- Walls fill only up to flat roof base level
SELECT ST_MakePolygon(ST_MakeLine(ARRAY[
      ST_Translate(p2, 0, minhei),
      ST_Translate(p1, 0, minhei),
      ST_Translate(p1, 0, hei),
      ST_Translate(p2, 0, hei),
      ST_Translate(p2, 0, minhei)])) AS way,
    LEAST(ST_Y(p1),ST_Y(p2)) AS lea, 1 AS hv,
    CASE WHEN ST_X(p1) &gt; ST_X(p2) THEN 'yes' ELSE 'no' END AS visible,
    degrees(ST_Azimuth(p2, p1)) AS azim, minhei, hei, 'area' AS fill, 1 AS diff
FROM (
    SELECT ST_PointN(way,generate_series(1, ST_NPoints(way) - 1)) AS p1,
        ST_PointN(way,generate_series(2, ST_NPoints(way))) AS p2,
        hei * 2 AS hei, minhei * 2 AS minhei
    FROM (
        SELECT (ST_Dump(ST_Boundary(way))).geom AS way, minhei, hei
        FROM buildings WHERE GeometryType(way) = 'POLYGON') p) a

                      -- Wall vertical lines up to flat roof level
UNION

SELECT ST_MakeLine(ST_Translate(p2, 0, minhei),
    ST_Translate(p2, 0, hei)) AS way,
    ST_Y(p2) AS lea, 1 AS hv,
    CASE WHEN (ST_X(p3) - ST_X(p2)) * (ST_X(p2) - ST_X(p1)) &lt; 0
        THEN CASE WHEN (ST_X(p2) - ST_X(p1)) * (ST_Y(p3) - ST_Y(p2)) -
                 (ST_X(p3) - ST_X(p2)) * (ST_Y(p2) - ST_Y(p1)) &lt; 0
            THEN 'border-yes-v'
            ELSE 'border-no-v' END
        WHEN ST_X(p1) &gt; ST_X(p2) THEN 'yes-v'
        ELSE 'no-v' END AS visible,
    -500 AS azim, minhei, hei, 'line' AS fill,
     1 - abs(abs(ST_Azimuth(p3, p2) - ST_Azimuth(p2, p1)) / 3.14159265358 - 1) AS diff -- TODO: fix the azimuth rollover
FROM (
    SELECT ST_PointN(way, generate_series(1, ST_NPoints(way) - 1))) AS p1,
        ST_PointN(way, generate_series(2, ST_NPoints(way))) AS p2,
        ST_PointN(way, (generate_series(2, ST_NPoints(way)) % (ST_NPoints(way) - 1)) + 1) AS p3,
        hei * 2 AS hei, minhei * 2 AS minhei
    FROM (
        SELECT (ST_Dump(ST_Boundary(way))).geom AS way, minhei, hei
        FROM buildings
        WHERE GeometryType(way) = 'POLYGON') p) a

                      -- Bottom lines
UNION

SELECT ST_Translate(ST_MakeLine(p1, p2), 0, minhei) AS way,
    LEAST(ST_Y(p1), ST_Y(p2)) as lea, 2 AS hv,
    CASE WHEN ST_X(p2) &gt; ST_X(p1) THEN 'no-h-d'
        ELSE 'no-h' END AS visible, -500 AS azim,
    minhei, minhei AS hei, 'line' AS fill, 1 AS diff
FROM (
    SELECT ST_PointN(way, generate_series(1, ST_NPoints(way) - 1)) as p1,
        ST_PointN(way, generate_series(2, ST_NPoints(way))) as p2, minhei
    FROM (
        SELECT (ST_Dump(ST_Boundary(ST_ForceRHR(way)))).geom AS way,
            minhei * 2 AS minhei
        FROM (
            SELECT minmax AS way, hei AS minhei
            FROM joined
            WHERE minmax IS NOT NULL) a
        WHERE way IS NOT NULL AND NOT ST_IsEmpty(way)) b) c
--                        WHERE
--                            (o.way IS NULL OR
--                             NOT ST_IsEmpty(ST_Difference(n.way, o.way)))
--                            AND GeometryType(ST_Multi(CASE WHEN o.way IS NOT NULL THEN ST_Difference(n.way, o.way) ELSE n.way END)) = 'MULTIPOLYGON') p) r

                      -- Flat roof fills
UNION

SELECT ST_Translate(way, 0, hei) AS way,
    ST_YMin(way) AS lea, 2 AS hv, 'yes-h' AS visible, -500 AS azim,
    hei AS minhei, hei, 'area' AS fill, 1 AS diff
FROM (
    SELECT maxmin AS way, hei * 2 AS hei
    FROM joined
    WHERE maxmin IS NOT NULL) p

                      -- Flat roof lines
UNION

SELECT ST_Translate(way, 0, hei) AS way, ST_YMin(way) AS lea, 2 AS hv,
    'no-h' AS visible, -500 AS azim, hei AS minhei, hei,
    'line' AS fill, 1 AS diff
FROM (
    SELECT maxmin AS way, hei * 2 AS hei
    FROM joined
    WHERE maxmin IS NOT NULL) p

                     -- Pyramid roof fills
UNION

SELECT ST_MakePolygon(ST_Translate(ST_MakeLine(ARRAY[p2, p1, p3, p2]), 0, hei))
      AS way,
    LEAST(ST_Y(p1), ST_Y(p2)) AS lea, 1 AS hv,
    -- See if the points are in RHR order
    -- TODO: use http://trac.osgeo.org/postgis/wiki/UsersWikiplpgsqlfunctions
    -- as an example to convert this into a function
    CASE WHEN (ST_X(p1) - ST_X(p2)) * (ST_Y(p1) - ST_Y(p3)) &lt;
            (ST_X(p1) - ST_X(p3)) * (ST_Y(p1) - ST_Y(p2))
        THEN 'yes' ELSE 'no' END AS visible,
    --- TODO: rename azimuth to opacity and incorporate the roof tilt into
    --- how opacity is calculated
    degrees(ST_Azimuth(p2, p1)) AS azim,
    hei AS minhei, hei + rhei AS hei, 'area' AS fill, 1 AS diff
FROM (
    SELECT ST_PointN(way, generate_series(1, ST_NPoints(way) - 1)) AS p1,
        ST_PointN(way, generate_series(2, ST_NPoints(way))) AS p2,
        ST_Translate(center, 0, rhei * 2) AS p3,
        hei * 2 AS hei, rhei * 2 AS rhei
    FROM (
        SELECT (ST_Dump(ST_Boundary(way))).geom AS way, hei, rhei,
            ST_Centroid(way) AS center
        FROM buildings WHERE GeometryType(way) = 'POLYGON' AND
            rshape IN ('pyramidal', '2.5')
        ) p
    ) a

                     -- Pyramid roof angle lines
UNION

SELECT ST_Translate(ST_MakeLine(ARRAY[p2, p3]), 0, hei) AS way,
    ST_Y(p2) AS lea, 1 AS hv,
    -- TODO: use http://trac.osgeo.org/postgis/wiki/UsersWikiplpgsqlfunctions
    -- as an example to convert this into a function
    -- TODO: yield border-yes-v on both borders
    -- Note: for simplicity we assume all angles convex for now
    CASE WHEN (ST_X(p1) - ST_X(p2)) * (ST_Y(p1) - ST_Y(p3)) &lt;
            (ST_X(p1) - ST_X(p3)) * (ST_Y(p1) - ST_Y(p2))
         THEN 'yes-v' ELSE
             CASE WHEN (ST_X(p2) - ST_X(p4)) * (ST_Y(p2) - ST_Y(p3)) &lt;
                     (ST_X(p2) - ST_X(p3)) * (ST_Y(p2) - ST_Y(p4))
             THEN 'border-yes-v' ELSE 'no-v' END END AS visible,
    -500 AS azim, hei AS minhei, hei + rhei AS hei, 'line' AS fill,
    0.4 AS diff -- TODO: calculate the real angle between the two surfaces
FROM (
    SELECT ST_PointN(way, generate_series(1, ST_NPoints(way) - 1)) AS p1,
        ST_PointN(way, generate_series(2, ST_NPoints(way))) AS p2,
        ST_Translate(center, 0, rhei * 2) AS p3,
        ST_PointN(way, (generate_series(2, ST_NPoints(way)) % (ST_NPoints(way) - 1)) + 1) AS p4,
        hei * 2 AS hei, rhei * 2 AS rhei
    FROM (
        SELECT (ST_Dump(ST_Boundary(way))).geom AS way, hei, rhei,
            ST_Centroid(way) AS center
        FROM buildings WHERE GeometryType(way) = 'POLYGON' AND
            rshape IN ('pyramidal', '2.5')
        ) p
    ) a

                      -- Pyramid roof horizontal lines
UNION

SELECT ST_Translate(ST_MakeLine(ARRAY[p2, p1]), 0, hei) AS way,
    LEAST(ST_Y(p1), ST_Y(p2)) AS lea, 2 AS hv,
    -- See if the points are in RHR order
    -- TODO: use http://trac.osgeo.org/postgis/wiki/UsersWikiplpgsqlfunctions
    -- as an example to convert this into a function
    CASE WHEN (ST_X(p1) - ST_X(p2)) * (ST_Y(p1) - ST_Y(p3)) &lt;
            (ST_X(p1) - ST_X(p3)) * (ST_Y(p1) - ST_Y(p2))
        THEN 'no-h' ELSE 'no-h-d' END AS visible,
    -500 AS azim,
    hei AS minhei, hei, 'line' AS fill, 1 AS diff
FROM (
    SELECT ST_PointN(way, generate_series(1, ST_NPoints(way) - 1)) AS p1,
        ST_PointN(way, generate_series(2, ST_NPoints(way))) AS p2,
        ST_Translate(center, 0, rhei * 2) AS p3,
        hei * 2 AS hei, rhei * 2 AS rhei
    FROM (
        SELECT (ST_Dump(ST_Boundary(way))).geom AS way, hei, rhei,
            ST_Centroid(way) AS center
        FROM buildings WHERE GeometryType(way) = 'POLYGON' AND
            rshape IN ('pyramidal', '2.5')
        ) p
    ) a

                     -- Skillion rooves
UNION

(WITH
 raw_roof AS (
     SELECT (ST_Dump(ST_Boundary(way))).geom AS way, way AS origway, hei, rhei
     FROM buildings WHERE GeometryType(way) = 'POLYGON' AND
         rshape IN ('skillion', '1.0')),

 raw_roof_direction AS (
     SELECT hei, rhei, way, origway,
         (ST_X(ST_PointN(way, num + 1)) - ST_X(ST_PointN(way, num))) /
           ST_Distance(ST_PointN(way, num + 1), ST_PointN(way, num)) AS px,
         (ST_Y(ST_PointN(way, num + 1)) - ST_Y(ST_PointN(way, num))) /
           ST_Distance(ST_PointN(way, num + 1), ST_PointN(way, num)) AS py
     FROM (
         SELECT hei * 2 AS hei, rhei * 2 AS rhei, way, origway,
             (SELECT num
              FROM generate_series(1, ST_NPoints(way) - 1) AS num
              ORDER BY ST_Distance(ST_PointN(way, num),
                  ST_PointN(way, num + 1)) DESC
              LIMIT 1)
         FROM raw_roof) AS a),

 rotated_roof AS (
     SELECT hei, rhei, px, py, ST_Affine(way, py, -px, px, py, 0, 0) AS rway,
         way, origway
     FROM raw_roof_direction),

 roof_helpers AS (
     SELECT way, origway, hei, rhei, px, py,
         ST_XMin(rway) AS min, ST_XMax(rway) AS max,
         rhei * 2 / (ST_XMax(rway) - ST_XMin(rway)) AS ratio
     FROM rotated_roof),

 roof_helpers_points AS (
     SELECT hei, rhei, px, py, min, max, ratio,
         ST_PointN(way, generate_series(1, ST_NPoints(way) - 1)) AS p1,
         ST_PointN(way, generate_series(2, ST_NPoints(way))) AS p2,
         ST_PointN(way, (generate_series(2, ST_NPoints(way)) % (ST_NPoints(way) - 1)) + 1) AS p3
     FROM roof_helpers)

 -- Roof fills
 SELECT ST_Affine(origway, 1, 0,
       py * ratio, 1 - px * ratio, 0, hei - min * ratio) AS way,
     ST_YMin(origway) AS lea, 1 AS hv,
     CASE WHEN 1 - px * ratio &gt; 0 THEN 'yes' ELSE 'no' END AS visible,
     degrees(ST_Azimuth(ST_Point(0, 0), ST_Point(px, py))) AS azim,
     hei AS minhei, hei + rhei AS hei, 'area' AS fill, 1 AS diff
 FROM roof_helpers

 -- Roof vertical lines
 UNION
 SELECT ST_MakeLine(ST_Translate(p2, 0, hei),
       ST_Translate(p2, 0, hei + (py * ST_X(p2) - px * ST_Y(p2) - min) * ratio))
       AS way,
     ST_Y(p2) AS lea, 1 AS hv,
     CASE WHEN (ST_X(p3) - ST_X(p2)) * (ST_X(p2) - ST_X(p1)) &lt; 0
          THEN CASE WHEN (ST_X(p2) - ST_X(p1)) * (ST_Y(p3) - ST_Y(p2)) -
                      (ST_X(p3) - ST_X(p2)) * (ST_Y(p2) - ST_Y(p1)) &lt; 0
                    THEN 'border-yes-v'
                    ELSE 'border-no-v' END
          WHEN ST_X(p1) &gt; ST_X(p2) THEN 'yes-v' ELSE 'no-v' END AS visible,
     -500 AS azim, hei, hei + rhei, 'line' AS fill,
     1 - abs(abs(ST_Azimuth(p3, p2) - ST_Azimuth(p2, p1)) / 3.14159265358 - 1) AS diff -- TODO: fix the azimuth rollover
 FROM roof_helpers_points

 -- Roof horizontal lines
 UNION
 SELECT ST_MakeLine(ARRAY[
       ST_Translate(p2, 0, hei + (py * ST_X(p2) - px * ST_Y(p2) - min) * ratio),
       ST_Translate(p1, 0, hei + (py * ST_X(p1) - px * ST_Y(p1) - min) * ratio)])
       AS way,
     LEAST(ST_Y(p1), ST_Y(p2)) AS lea, 2 AS hv,
     CASE WHEN 1 - px * ratio &gt; 0 OR ST_X(p2) &gt; ST_X(p1)
          THEN 'no-h' ELSE 'no-h-d' END AS visible,
     -500 AS azim,
     hei AS minhei, hei, 'line' AS fill, 1 AS diff
 FROM roof_helpers_points

 -- Wall fills
 UNION
 SELECT ST_MakePolygon(ST_Translate(ST_MakeLine(ARRAY[
       p2, p1,
       ST_Translate(p1, 0, (py * ST_X(p1) - px * ST_Y(p1) - min) * ratio),
       ST_Translate(p2, 0, (py * ST_X(p2) - px * ST_Y(p2) - min) * ratio),
       p2]), 0, hei)) AS way,
     LEAST(ST_Y(p1), ST_Y(p2)) AS lea, 1 AS hv,
     CASE WHEN ST_X(p1) &gt; ST_X(p2) THEN 'yes' ELSE 'no' END AS visible,
     degrees(ST_Azimuth(p2, p1)) AS azim, hei AS minhei, hei + rhei AS hei,
     'area' AS fill, 1 AS diff
 FROM roof_helpers_points
)

) order by minhei, lea DESC, fill, hv, hei
) as text
  </Parameter>
  <Parameter name="geometry_field">way</Parameter>
  <Parameter name="geometry_table">planet_osm_line</Parameter>
 </Datasource>
</Layer>
